// Generated by BUCKLESCRIPT VERSION 1.4.2 , PLEASE EDIT WITH CARE
'use strict';

var Bytes = require('bs-platform/lib/js/bytes');
var Curry = require('bs-platform/lib/js/curry');
var $$String = require('bs-platform/lib/js/string');
var Caml_int32 = require('bs-platform/lib/js/caml_int32');
var Pervasives = require('bs-platform/lib/js/pervasives');
var Caml_string = require('bs-platform/lib/js/caml_string');

var default_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

function of_char($staropt$star, x) {
    var alphabet = $staropt$star ? $staropt$star[0] : default_alphabet;
    if (x === /* "=" */ 61) {
        return 0;
    } else {
        return $$String.index(alphabet, x);
    }
}

function to_char($staropt$star, x) {
    var alphabet = $staropt$star ? $staropt$star[0] : default_alphabet;
    return Caml_string.get(alphabet, x);
}

function decode(alphabet, input) {
    var length = input.length;
    var input$1 = length % 4
        ? input + $$String.make(4 - length % 4 | 0, /* "=" */ 61)
        : input;
    var length$1 = input$1.length;
    var words = length$1 / 4 | 0;
    var padding = length$1 !== 0
        ? Caml_string.get(input$1, length$1 - 2 | 0) === /* "=" */ 61
                ? 2
                : Caml_string.get(input$1, length$1 - 1 | 0) === /* "=" */ 61 ? 1 : 0
        : 0;
    var output = Bytes.make(Caml_int32.imul(words, 3) - padding | 0, /* "\000" */ 0);
    for (var i = 0, i_finish = words - 1 | 0; i <= i_finish; ++i) {
        var a = of_char(alphabet, Caml_string.get(input$1, (i << 2) + 0 | 0));
        var b = of_char(alphabet, Caml_string.get(input$1, (i << 2) + 1 | 0));
        var c = of_char(alphabet, Caml_string.get(input$1, (i << 2) + 2 | 0));
        var d = of_char(alphabet, Caml_string.get(input$1, (i << 2) + 3 | 0));
        var n = a << 18 | b << 12 | c << 6 | d;
        var x = n >>> 16 & 255;
        var y = n >>> 8 & 255;
        var z = n & 255;
        output[Caml_int32.imul(3, i) + 0 | 0] = Pervasives.char_of_int(x);
        if (i !== (words - 1 | 0) || padding < 2) {
            output[Caml_int32.imul(3, i) + 1 | 0] = Pervasives.char_of_int(y);
        }
        if (i !== (words - 1 | 0) || padding < 1) {
            output[Caml_int32.imul(3, i) + 2 | 0] = Pervasives.char_of_int(z);
        }
    }
    return Curry._1(Bytes.unsafe_to_string, output);
}

function encode($staropt$star, alphabet, input) {
    var pad = $staropt$star ? $staropt$star[0] : /* true */ 1;
    var length = input.length;
    var words = (length + 2 | 0) / 3 | 0;
    var padding_len = length % 3 ? 3 - length % 3 | 0 : 0;
    var output = Bytes.make(words << 2, /* "\000" */ 0);
    var get = function(i) {
        if (i >= length) {
            return 0;
        } else {
            return Caml_string.get(input, i);
        }
    };
    for (var i = 0, i_finish = words - 1 | 0; i <= i_finish; ++i) {
        var x = get(Caml_int32.imul(3, i) + 0 | 0);
        var y = get(Caml_int32.imul(3, i) + 1 | 0);
        var z = get(Caml_int32.imul(3, i) + 2 | 0);
        var n = x << 16 | y << 8 | z;
        var a = n >>> 18 & 63;
        var b = n >>> 12 & 63;
        var c = n >>> 6 & 63;
        var d = n & 63;
        output[(i << 2) + 0 | 0] = to_char(alphabet, a);
        output[(i << 2) + 1 | 0] = to_char(alphabet, b);
        output[(i << 2) + 2 | 0] = to_char(alphabet, c);
        output[(i << 2) + 3 | 0] = to_char(alphabet, d);
    }
    for (var i$1 = 1; i$1 <= padding_len; ++i$1) {
        output[output.length - i$1 | 0] = /* "=" */ 61;
    }
    if (pad) {
        return Curry._1(Bytes.unsafe_to_string, output);
    } else {
        return Bytes.sub_string(output, 0, output.length - padding_len | 0);
    }
}

var uri_safe_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';

exports.default_alphabet = default_alphabet;
exports.uri_safe_alphabet = uri_safe_alphabet;
exports.decode = decode;
exports.encode = encode;
/* No side effect */
