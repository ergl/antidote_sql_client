const kv = require('./db/kv')
const entities = require('./entities/entity')

// number -> string -> {} -> connection
function make(port, url, opts = {}) {
    // TODO: Separate connection into a separate object to track indices?
    return kv.createRemote(port, url, opts)
}

// connection -> promise connection
function startTransaction(conn, opts = {}) {
    return conn.startTransaction()
}

// connection -> promise commit_time
function commitTransaction(tx) {
    return tx.commit()
}

// connection -> (connection -> any) -> {} -> promise {ct: commit_time, result: any}
// Run a function inside a transaction.
function runTransaction(conn, execute_fn, opts) {
    const tx_body = tx => {
        return execute_fn(tx).then(values => {
            return commitTransaction(tx).then(ct => ({ct: ct, result: values}))
        })
    }
    return startTransaction(conn, opts).then(tx_body)
}

// connection -> string | [string] -> promise bool
// Given any key, check that the key points to a valid object
function checkFkExists(conn, fk) {
    return getKeys(conn, fk).then(v => {
        return Array.isArray(v) ? v.every(e => e !== undefined) : v !== undefined
    })
}

function putWithFKCheck(conn, entity) {
    const ref = entityRef(conn, entity)
    const values = entity.content
    const fks = entity.fks

    // Delay storing the main entity until we check the foreign keys
    const store_main_entity = () => conn.update(ref.set(values))
    // Auto-insert indices
    const store_indices = ct => {
        const indices = entity.indices
        if (indices.length !== 0) {
            return createIndex(conn, entity)
        }

        return ct
    }

    let fk_exist
    if (fks.length !== 0) {
        // Delay promises starting
        const fk_checks = () => fks.map(fk => checkFkExists(conn, fk))
        // Check that all fks exist
        fk_exist = Promise.all(fk_checks()).then(checks => checks.every(e => e)).catch(_ => false)
    } else {
        fk_exist = Promise.resolve(true)
    }

    return fk_exist.then(exist => {
        if (exist) {
            return store_main_entity().then(store_indices)
        }

        throw "Can't complete, fks were not satisfied"
    })
}

// connection -> entity -> string -> promise commit_time
function putInBucket(conn, entities, bucket) {
    // This will always run inside a transaction
    // Safe to get external objects
    const default_bucket = conn.defaultBucket
    conn.defaultBucket = bucket

    let result
    if (Array.isArray(entities)) {
        // We could put them in parallel and take the higher commit timestamp,
        // but then we can't run this method inside a transaction, as a tx doesn't
        // expose the getLastCommitTimestamp property.
        const [head, ...tail] = entities
        result = tail.reduce((acc, ent) => {
            return acc.then(_ct => putWithFKCheck(conn, ent))
        }, putWithFKCheck(conn, head))
    } else {
        result = putWithFKCheck(conn, entities)
    }

    conn.defaultBucket = default_bucket
    return result
}

// To index a table `tbl` over field `fld`,
// create a new table `tbl_fld` with with schema pk -> (val, fk)
// where `pk` is an autogenerated (primary) key, `val` is the value of
// `tbl.fld` and `fk` is a foreign key to `tbl.pk`
function createIndex(conn, entity, opts = { inside_trans: false }) {
    const [{field, module}, ...tail] = entity.indices
    const hd_idx_entity = module.make(entity.id, entity.content[field])

    // Store all sequentially, so we get the largest commit time (ct)
    return tail.reduce(function(acc, {field, module}) {
        return acc.then(_ => {
            const index_entity = module.make(entity.id, entity[field])
            return put_raw(conn, index_entity, opts)
        })
    }, put_raw(conn, hd_idx_entity, opts))
}

function put_raw(conn, entity, opts = { bucket: conn.defaultBucket }) {
    // same as put, but don't create a new transaction
    // not exposed to the outside, only meant for internal use
    return putInBucket(conn, entity, opts.bucket)
}

// connection -> entity | [entity] -> {} -> promise commit_time
function put(conn, entity, opts = { bucket: conn.defaultBucket }) {
    // If it has fk or indexes, run it inside a transaction
    // ^ -> Always run inside a transaction
    const run = tx => {
        const bucket = opts.bucket || tx.defaultBucket
        return putInBucket(tx, entity, bucket)
    }

    return runTransaction(conn, run)
}

// connection -> entity -> register
function entityRef(conn, entity) {
    return Array.isArray(entity) ? entity.map(e => conn.register(e.id)) : conn.register(entity.id)
}

// connection -> string | [string] -> string | [string] -> promise (any | [any])
function _get(conn, keys, field = []) {
    const read_fields = function(values) {
        return values.map((v, idx) => entities.readField(v, field[idx]))
    }

    const result = kv.get(conn, keys)
        .then(read_fields)
        .catch(err => {
            console.error("_get failed with", err)
            return [undefined]
        })
    return keys.length !== 1 ? result : result.then(r => r[0])
}

// connection -> entity | [entity] -> string | [string] -> promise (any | [any])
// Read the contents of an entity from the database.
// Returns the _contents_ of the entity (not the entity itself) or `undefined`.
//
// Warning: it is not expected that someone will store `undefined` as an object in the database.
function get(conn, entity, field = []) {
    const to_read = Array.isArray(entity) ? entity : [entity]
    const keys = to_read.map(e => e.id)
    return getKeys(conn, keys, field)
}

// connection -> string | [string] -> string | [string] -> promise (any | [any])
// Same as get, but operate on raw key strings.
// If the value doesn't exist, it will return `undefined`
//
// Warning: it is not expected that someone will store `undefined` as an object in the database,
// if the user does, then there is no guarantee that this function will work.
function getKeys(conn, keys, field = []) {
    return _get(conn, keys, field)
}

module.exports = {
    make,
    put,
    get,
    getKeys,
    runTransaction
}
